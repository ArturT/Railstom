#!/bin/bash
# Put this file in /etc/init.d/
#
# sidekiq    Init script for Sidekiq
#
# Description: Starts and stops Sidekiq message processor for rails application.
#
# User-specified exit parameters used in this script:
#
# Exit Code 5 - Incorrect User ID
# Exit Code 6 - Directory not found

APP_NAME=railstom
APP_DEFAULT_ENV=production
APP_DIR=/home/rubyuser/rails_apps/${APP_NAME}-${APP_DEFAULT_ENV}/current
APP_CONFIG=${APP_DIR}/config/sidekiq.yml
LOG_FILE=$APP_DIR/log/sidekiq_${APP_DEFAULT_ENV}.log
LOCK_FILE=$APP_DIR/tmp/pids/sidekiq-${APP_NAME}-${APP_DEFAULT_ENV}.lock
PID_FILE=$APP_DIR/tmp/pids/sidekiq-${APP_NAME}-${APP_DEFAULT_ENV}.pid
GEMFILE=$APP_DIR/Gemfile
SIDEKIQ=sidekiq
BUNDLE=bundle

START_CMD="$BUNDLE exec $SIDEKIQ -e $APP_DEFAULT_ENV -P $PID_FILE -C $APP_CONFIG"
RETVAL=0


start() {
  status

  if [ $? -eq 1 ]; then
    [ `id -u` == '0' ] || (echo "$SIDEKIQ runs as root only."; exit 5)
    [ -d $APP_DIR ] || (echo "$APP_DIR not found! Exiting."; exit 6)
    cd $APP_DIR
    echo "Starting $SIDEKIQ message processor..."
    $START_CMD >> $LOG_FILE 2>&1 &
    RETVAL=$?
    # Sleeping for 8 seconds for process to be precisely visible in process table - see status ()
    sleep 8
    [ $RETVAL -eq 0 ] && touch $LOCK_FILE
    return $RETVAL
  else
    echo "$SIDEKIQ message processor is already running..."
  fi
}

stop() {
  echo "Stopping $SIDEKIQ message processor..."
  SIG="INT"
  kill -$SIG `cat $PID_FILE`
  RETVAL=$?
  [ $RETVAL -eq 0 ] && rm -f $LOCK_FILE
  return $RETVAL
}


status() {
  ps -ef | egrep "sidekiq [0-9]+.[0-9]+.[0-9]+ ${APP_NAME}-${APP_DEFAULT_ENV}" | grep -v grep
  return $?
}


case "$1" in
  start)
    start
    ;;
  stop)
    stop
    ;;
  restart|force-reload)
    stop
    sleep 1
    start
    ;;
  status)
    status

    if [ $? -eq 0 ]; then
       echo "$SIDEKIQ message processor is running..."
       RETVAL=0
     else
       echo "$SIDEKIQ message processor is stopped."
       RETVAL=1
     fi
    ;;
  *)
    echo "Usage: $0 {start|stop|restart|force-reload|status}"
    exit 0
    ;;
esac
exit $RETVAL
